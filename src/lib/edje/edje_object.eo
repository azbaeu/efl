import edje_types;

// FIXME: This EO doc needs a direct link to the "edcref" doc

class Edje.Object (Efl.Canvas.Group, Efl.File, Efl.Container, Efl.Part,
                   Efl.Observer, Efl.Ui.Base, Efl.Canvas.Layout_Calc,
                   Efl.Canvas.Layout_Signal, Efl.Canvas.Layout_Group,
                   Efl.Player, Efl.Gfx.Color_Class, Efl.Gfx.Text_Class,
                   Efl.Gfx.Size_Class)
{
   [[Edje object class]]
   legacy_prefix: edje_object;
   eo_prefix: edje_obj;
   event_prefix: edje_object;
   data: Edje;
   methods {
      @property animation {
         [[Whether this object is animating or not.

           This property indicates whether animations are stopped or not.
           Animations here refer to transitions between states.

           If animations are disabled, transitions between states (as
           defined in EDC) are then instantaneous. This is conceptually similar
           to setting the @Efl.Player.play_speed to an infinitely high
           value.
         ]]
         get {
            [[Get the current state of animation, $true by default.]]
         }
         set {
            [[Start or stop animating this object.]]
         }
         values {
            on: bool; [[The animation state, $true by default.]]
         }
      }
      @property perspective {
         set {
            [[Sets the given perspective object on this Edje object.

              Make the given perspective object be the default perspective for this Edje
              object.

              There can be only one perspective object per Edje object, and if a
              previous one was set, it will be removed and the new perspective object
              will be used.

              An Edje perspective will only affect a part if it doesn't point to another
              part to be used as perspective.

              \@ref edje_object_perspective_new()
              See also @.perspective.get()
              \@ref edje_perspective_set()]]
            values {
                ps: ptr(Edje.Perspective); [[The perspective object that will be used.]]
            }
         }
         get {
            [[Gets the current perspective used on this Edje object.

              See also @.perspective.set()]]
            values {
                @cref ps: Edje.Perspective; [[The perspective object that will be used.]]
            }
         }
      }

      // TODO: Legacy only. EO may rely on futures.
      preload {
         [[Preloads the images on the Edje Object in the background.

           This function requests the preload of all data images (on the given
           object) in the background. The work is queued before being processed
           (because there might be other pending requests of this type).
           It emits a signal "preload,done" when finished.

           Note: Use $true on scenarios where you don't need
           the image data preloaded anymore.]]

         return: bool; [[$false if obj was not a valid Edje object
                         otherwise $true]]
         params {
            @in cancel: bool; [[$false will add it the preloading work queue,
                                $true will remove it (if it was issued before).]]
         }
      }
      @property load_error {
         get {
            [[Gets the (last) file loading error for a given Edje object

              This function is meant to be used after an Edje EDJ file
              loading, what takes place with the $file_set() function. If that
              function does not return $true, one should check for the reason
              of failure with this one.
            ]]
            legacy: null;
         }
         values {
            error: Efl.Image.Load.Error(Efl.Image.Load.Error.generic);
               [[The load error code.]]
         }
      }

      access_part_iterate @beta {
         [[Iterates over all accessibility-enabled part names.]]
         legacy: null;
         return: iterator<string> @owned; [[Part name iterator]]
      }

      /* TEXT PART APIS BEGIN ---------------------------------------------- */
      @property text_change_cb {
         set {
            [[Sets the object text callback.

              This function sets the callback to be called when the text changes.]]
         }
         values {
            func: Edje.Text.Change_Cb; [[The callback function to handle the text change]]
            data: void_ptr; [[The data associated to the callback function.]]
         }
      }
      /* TEXT PART APIS END ------------------------------------------------ */

      @property seat {
         get {
            [[Returns the seat device given its Edje's name.

              Edje references seats by a name that differs from Evas.
              Edje naming follows a incrementional convention: first
              registered name is "seat1", second is "seat2", differently
              from Evas.

              @since 1.19]]

            return: Efl.Input.Device; [[The seat device or $null if not found.]]
         }
         keys {
            name: stringshare; [[The name's character string.]]
         }
      }
      @property seat_name {
         get {
            [[Gets the name given to a set by Edje.

              Edje references seats by a name that differs from Evas.
              Edje naming follows a incrementional convention: first
              registered name is "seat1", second is "seat2", differently
              from Evas.

              @since 1.19]]

            return: stringshare; [[The name's character string or $null if not found.]]
         }
         keys {
            device: Efl.Input.Device; [[The seat device]]
         }
      }
   }
   implements {
      Efl.Gfx.visible { set; }
      Efl.Gfx.position { set; }
      Efl.Gfx.size { set; }
      Efl.Object.constructor;
      Efl.Object.debug_name_override;
      Efl.Canvas.Object.no_render { set; }
      Efl.Canvas.Object.paragraph_direction { set; }
      Efl.Gfx.Color_Class.color_class { get; set; }
      Efl.Gfx.Color_Class.color_class_description { get; }
      Efl.Gfx.Color_Class.color_class_del;
      Efl.Gfx.Color_Class.color_class_clear;
      Efl.Gfx.Text_Class.text_class { get; set; }
      Efl.Gfx.Text_Class.text_class_del;
      Efl.Gfx.Size_Class.size_class { get; set; }
      Efl.Gfx.Size_Class.size_class_del;
      Efl.Canvas.Group.group_calculate;
      Efl.Canvas.Layout_Calc.calc_auto_update_hints { get; set; }
      Efl.Canvas.Layout_Calc.calc_size_min;
      Efl.Canvas.Layout_Calc.calc_parts_extends;
      Efl.Canvas.Layout_Calc.calc_freeze;
      Efl.Canvas.Layout_Calc.calc_thaw;
      Efl.Canvas.Layout_Calc.calc_force;
      Efl.Canvas.Layout_Group.group_size_min { get; }
      Efl.Canvas.Layout_Group.group_size_max { get; }
      Efl.Canvas.Layout_Group.group_data { get; }
      Efl.Canvas.Layout_Signal.message_send;
      Efl.Canvas.Layout_Signal.signal_callback_add;
      Efl.Canvas.Layout_Signal.signal_callback_del;
      Efl.Canvas.Layout_Signal.signal_emit;
      Efl.Canvas.Layout_Signal.signal_process;
      Efl.Ui.Base.mirrored { set; get; }
      Efl.Ui.Base.language { set; get; }
      Efl.Ui.Base.scale { set; get; }
      Efl.Ui.Base.base_scale { get; }
      Efl.File.mmap { get; set; }
      Efl.Container.content_remove;
      Efl.Part.part; [[Returns @Efl.Canvas.Layout.Part.]]
      Efl.Observer.update;
      Efl.Player.playable { get; }
      Efl.Player.play { get; set; }
      Efl.Player.play_speed { get; set; }
   }
   events {
      recalc; [[Edje re-calculated the object.]]
      circular,dependency; [[Edje found circular dependencies between parts of the object.]]
   }
}
