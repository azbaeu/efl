import efl_text_types;

enum Efl.Text.Format.Wrap {
   [[Wrap mode of the text (not in effect if not multiline)]]
   none, [[No wrapping]]
   char, [[Wrap mode character]]
   word, [[Wrap mode word]]
   mixed, [[Wrap mode mixed]]
   hyphenation [[Wrap mode hyphenation]]
}

enum Efl.Text.Format.Horizontal_Alignment_Auto_Type {
   [[Auto-horizontal alignment of the text]]
   legacy: efl_text_horizontal_alignment_auto;
   none,   [[No auto-alignment rule]]
   normal, [[Respects LTR/RTL (bidirectional) settings]]
   locale, [[Respects locale's langauge settings]]
   end     [[Text is places at opposite side of LTR/RTL (bidirectional) settings]]
}

interface Efl.Text.Format {
   [[The look and layout of the text

     The text format can affect the geometry of the text object, as well as
     how characters are presented.

     @since 1.20
   ]]
   eo_prefix: efl_text;
   methods {
      @property ellipsis {
         [[Ellipsis value (number from -1.0 to 1.0)]]
         values
         {
            value: double; [[Ellipsis value]]
         }
      }

      @property wrap {
         [[Wrap mode for use in the text]]
         values {
            wrap: Efl.Text.Format.Wrap; [[Wrap mode]]
         }
      }

      @property multiline {
         [[Multiline is enabled or not]]
         values {
            enabled: bool; [[$true if multiline is enabled, $false otherwise]]
         }
      }

      @property halign_auto_type {
         [[Horizontal alignment of text]]
         values {
            value: Efl.Text.Format.Horizontal_Alignment_Auto_Type; [[Alignment type]]
         }
      }

      @property halign {
         [[Horizontal alignment of text]]
         values {
            value: double; [[Horizontal alignment value]]
         }
      }

      @property valign {
         [[Vertical alignment of text]]
         values {
            value: double; [[Vertical alignment value]]
         }
      }

      @property linegap {
         [[Minimal line gap (top and bottom) for each line in the text

           $value is absolute size.
         ]]
         values
         {
            value: double; [[Line gap value]]
         }
      }

      @property linerelgap {
         [[Relative line gap (top and bottom) for each line in the text

           The original line gap value is multiplied by $value.
         ]]
         values
         {
            value: double; [[Relative line gap value]]
         }
      }

      @property tabstops {
         [[Tabstops value]]
         values
         {
            value: int; [[Tapstops value]]
         }
      }

      @property password {
         [[Whether text is a password]]
         values
         {
            enabled: bool; [[$true if the text is a password, $false otherwise]]
         }
      }

      @property replacement_char {
         [[The character used to replace characters that can not be displayed

           Currently, only used to replace characters if @.password
           is enabled.
         ]]
         values {
            repch: string; [[Replacement character]]
         }
      }
      format_insert {
         [[Inserts a format at the cursor's position.

           The format is specified with a format string e.g. "color=#fff".
           The inserted format will be inlined in the cursor at the position.
           Common usage is to also insert a closing format e.g. "/color" to
           match the opening format at the end of the range the format is
           expected to apply.
         ]]
         params {
            cur: ptr(Efl.Text.Cursor.Cursor); [[The cursor position to insert]]
            format: string; [[The format]]
         }
      }
      item_insert {
         [[Inserts a object item at specified position.

           This adds a placeholder to be queried by higher-level code,
           which in turn place graphics on top of it. It essentially places an
           OBJECT REPLACEMENT CHARACTER and set a special annotation to it.
         ]]
         legacy: null;
         params {
            cur: ptr(Efl.Text.Cursor.Cursor); [[Cursor object]]
            @in item: string;   [[Item key to be used in higher-up
                                  code to query and decided what image, emoticon
                                  etc. to embed.]]
            @in format: string; [[Size format of the inserted item.
                                  This hints how to size the item in the text.]]
         }
      }
      item_geometry_get {
         [[Queries a given object item for its geometry.

           Returns whether the current position is an item.

           @since 1.18
         ]]
         legacy: null;
         params {
            @in item: ptr(const(Efl.Text.Format.Item)); [[Item to query]]
            @out x: int; [[X coordinate of the annotation]]
            @out y: int; [[Y coordinate of the annotation]]
            @out w: int; [[Width of the annotation]]
            @out h: int; [[Height of the annotation]]
         }
         return: bool; [[$true if query was succcessful, $false otherwise]]
      }
      format_get {
         [[Inserts a format at specified position.

           Given a cursor, inserts a format node in its position. This position
           can be queried to get the format node's handle.
         ]]
         legacy: null;
         params {
            @in cur: ptr(const(Efl.Text.Cursor.Cursor)); [[Cursor object]]
         }
         return: ptr(const(Efl.Text.Format.Format)); [[Format handle]]
      }
      format_string_get {
         [[Inserts a format at specified position.

           Given a cursor, inserts a format node in its position. This position
           can be queried to get the format node's handle.
         ]]
         legacy: null;
         params {
            @in cur: ptr(const(Efl.Text.Format.Format)); [[Cursor object]]
         }
         return: string; [[The format description]]
      }
      formats_get {
         [[Returns an iterator of all the handles in a range.

           If $start is $null, start from beginning of the text.
           If $end is $null, end at end of the text.
           If both $null, return for the whole text.

           @since 1.21
         ]]
         legacy: null;
         params {
              @in start: ptr(const(Efl.Text.Cursor.Cursor)); [[Start of range]]
              @in end:   ptr(const(Efl.Text.Cursor.Cursor)); [[End of range]]
         }
         return: iterator<ptr(Efl.Text.Format.Format)> @owned; [[Iterator of format handles]]
      }
      items_get {
         [[Returns an iterator of all the item handles in a range.

           If $start is $null, start from beginning of the text.
           If $end is $null, end at end of the text.
           If both $null, return for the whole text.

           @since 1.21
         ]]
         legacy: null;
         params {
              @in start: ptr(const(Efl.Text.Cursor.Cursor)); [[Start of range]]
              @in end:   ptr(const(Efl.Text.Cursor.Cursor)); [[End of range]]
         }
         return: iterator<ptr(Efl.Text.Format.Item)> @owned; [[Iterator of item handles]]
      }
      item_string_get {
         [[Gets the item string]]
         legacy: null;
         params {
            @in cur: ptr(const(Efl.Text.Format.Item)); [[Cursor object]]
         }
         return: string; [[The item string]]
      }
   }
}
